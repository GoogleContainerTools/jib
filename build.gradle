// define all versioned plugins here and apply in subprojects as necessary without version
plugins {
  id 'com.github.sherter.google-java-format' version '0.8' apply false
  id 'net.ltgt.apt' version '0.19' apply false
  id 'net.ltgt.errorprone' version '0.6' apply false
  id 'net.researchgate.release' version '2.7.0' apply false
  id 'com.gradle.plugin-publish' version '0.10.1' apply false
  id 'io.freefair.maven-plugin' version '3.8.1' apply false

  // apply so we can correctly configure the test runner to be gradle at the project level
  id 'org.jetbrains.gradle.plugin.idea-ext' version '0.7'
}

// run tests in intellij using gradle test runner
idea.project.settings {
  delegateActions {
    delegateBuildRunToGradle = false
    testRunner = 'GRADLE'
  }
}

import net.ltgt.gradle.errorprone.CheckSeverity

project('jib-maven-plugin-extension-api') {
  apply plugin: 'java-library'
}

subprojects {
  group 'com.google.cloud.tools'

  repositories {
    mavenCentral()
  }

  apply plugin: 'java'
  apply plugin: 'checkstyle'
  apply plugin: 'com.github.sherter.google-java-format'
  apply plugin: 'net.ltgt.apt'
  apply plugin: 'net.ltgt.errorprone'

  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8
  compileJava.options.encoding = 'UTF-8'
  compileJava.options.compilerArgs += [ '-Xlint:deprecation' ]
  compileTestJava.options.compilerArgs += [ '-Xlint:deprecation' ]

  /* PROJECT DEPENDENCY VERSIONS */
  // define all common versioned dependencies here
  project.ext.dependencyVersions = [
    // For Google libraries, check <http-client-bom.version>, <google.auth.version>, <guava.version>,
    // ... in https://github.com/googleapis/google-cloud-java/blob/master/google-cloud-clients/pom.xml
    // for best compatibility.
    GOOGLE_HTTP_CLIENT: '1.34.0',
    GOOGLE_HTTP_CLIENT_APACHE_V2: '1.34.0',
    GOOGLE_AUTH_LIBRARY_OAUTH2_HTTP: '0.18.0',
    GUAVA: '28.1-jre',
    JSR305: '3.0.2', // transitively pulled in by GUAVA

    COMMONS_COMPRESS: '1.19',
    JACKSON_DATABIND: '2.9.10',
    ASM: '7.3.1',
    PICOCLI: '4.2.0',

    MAVEN_API: '3.5.2',

    //test
    JUNIT: '4.12',
    MOCKITO_CORE: '3.2.4',
    SLF4J_API: '1.7.25',
    SYSTEM_RULES: '1.19.0',
  ]

  // Use this to ensure we correctly override transitive dependencies
  // TODO: There might be a plugin that does this
  task ensureTransitiveDependencyOverrides {
    def rules = [
        'google-http-client': dependencyVersions.GOOGLE_HTTP_CLIENT,
        'google-http-client-apache-v2': dependencyVersions.GOOGLE_HTTP_CLIENT_APACHE_V2,
    ]
    doLast {
      configurations.runtimeClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        def dependency = artifact.moduleVersion.id
        if (rules[dependency.name] && rules[dependency.name] != dependency.version) {
          throw new GradleException(
              dependency.name + ' version error in ' + project
              + ', expected:' + rules[dependency.name]
              + ', found:' + dependency.version);
        }
      }
    }
  }
  compileJava.dependsOn ensureTransitiveDependencyOverrides
  /* PROJECT DEPENDENCY VERSIONS */

  /* ERROR PRONE */
  dependencies {
    // NullAway errorprone plugin
    annotationProcessor 'com.uber.nullaway:nullaway:0.7.9'
    errorprone 'com.google.errorprone:error_prone_core:2.3.4'
    // Using github.com/google/error-prone-javac is required when running on
    // JDK 8. Remove when migrating to JDK 11.
    if (System.getProperty('java.version').startsWith('1.8.')) {
      errorproneJavac('com.google.errorprone:javac:9+181-r4173-1')
    }
  }

  // Adds NullAway errorprone checks.
  tasks.withType(JavaCompile) {
    if (!name.toLowerCase().contains('test')) {
      options.errorprone {
        check('NullAway', CheckSeverity.ERROR)
        option('NullAway:ExcludedFieldAnnotations', 'org.apache.maven.plugins.annotations.Component')
        option('NullAway:AnnotatedPackages', 'com.google.cloud.tools')
      }
    }
  }
  /* ERROR PRONE */

  /* GOOGLE JAVA FORMAT */
  googleJavaFormat {
    toolVersion = '1.6'
  }
  check.dependsOn verifyGoogleJavaFormat
  /* GOOGLE JAVA FORMAT */

  /* CHECKSTYLE */
  checkstyle {
    toolVersion = '8.29'

    // use google checks from the jar
    def googleChecks = resources.text.fromArchiveEntry(configurations.checkstyle[0], 'google_checks.xml').asString()

    // set the location of the suppressions file referenced in google_checks.xml
    configProperties['org.checkstyle.google.suppressionfilter.config'] = getConfigDirectory().file('checkstyle-suppressions.xml').get().toString()

    // add in copyright header check on only java files (replace the last </module> in file)
    def copyrightChecks = '''
        <module name="RegexpHeader">
            <property name="headerFile" value="${config_loc}/copyright-java.header"/>
            <property name="fileExtensions" value="java"/>
            <property name="id" value="header"/>
        </module>
    </module>
    '''
    googleChecks = googleChecks.substring(0, googleChecks.lastIndexOf('</module>')) + copyrightChecks

    // this is the actual checkstyle config
    config = resources.text.fromString(googleChecks)

    maxErrors = 0
    maxWarnings = 0
  }
  /* CHECKSTYLE */

  /* TEST CONFIG */
  tasks.withType(Test) {
    reports.html.setDestination file("${reporting.baseDir}/${name}")
  }

  test {
    testLogging {
      showStandardStreams = true
      exceptionFormat = 'full'
    }
  }
  // jar to export tests classes for import in other project by doing:
  // testCompile project(path:':project-name', configuration:'tests')
  task testJar(type: Jar) {
    from sourceSets.test.output.classesDirs
    classifier = 'tests'
  }
  // to import resources do: sourceSets.test.resources.srcDirs project(':project-name').sourceSets.test.resources

  configurations {
    tests
  }

  artifacts {
    tests testJar
  }
  /* TEST CONFIG */

  /* INTEGRATION TESTS */
  sourceSets {
    integrationTest {
      java.srcDir file('src/integration-test/java')
      resources.srcDir file('src/integration-test/resources')
    }
  }

  configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntime.extendsFrom testRuntime
  }

  dependencies {
    integrationTestImplementation sourceSets.main.output
    integrationTestImplementation sourceSets.test.output
    integrationTestImplementation configurations.compile
    integrationTestImplementation configurations.testImplementation
    integrationTestImplementation configurations.runtime
    integrationTestImplementation configurations.testRuntime
  }

  // Integration tests must be run explicitly
  task integrationTest(type: Test) {
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    systemProperty '_JIB_DISABLE_USER_AGENT', true
  }

  integrationTest.dependsOn test

  task integrationTestJar(type: Jar) {
    from sourceSets.integrationTest.output.classesDirs
    classifier = 'integration-tests'
  }

  configurations {
    integrationTests
  }

  artifacts {
    integrationTests integrationTestJar
  }
  /* INTEGRATION TESTS */

  /* JAVADOC ENFORCEMENT */
  // Fail build on javadoc warnings
  tasks.withType(Javadoc) {
    options.addBooleanOption('Xwerror', true)
  }
  assemble.dependsOn javadoc
  /* JAVADOC ENFORCEMENT */

  /* JAR */
  jar {
    manifest {
      attributes 'Implementation-Title': project.name,
                 'Implementation-Version': version,
                 'Built-By': System.getProperty('user.name'),
                 'Built-Date': new Date(),
                 'Built-JDK': System.getProperty('java.version'),
                 'Built-Gradle': gradle.gradleVersion
    }
  }
  /* JAR */

  /* MAVEN CENTRAL RELEASES */
  // for projects that release to maven central
  project.ext.configureMavenRelease = {
    apply plugin: 'maven-publish'
    task sourceJar(type: Jar) {
      from sourceSets.main.allJava
      classifier 'sources'
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
      from javadoc.destinationDir
      classifier 'javadoc'
    }

    publishing {
      publications {
        mavenJava(MavenPublication) {
          pom {
            // to be filled by subproject after calling configure configureMavenRelease
            // name = ''
            // description = ''

            url = 'https://github.com/GoogleContainerTools/jib'
            inceptionYear = '2018'

            licenses {
              license {
                name = 'The Apache License, Version 2.0'
                url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                distribution = 'repo'
              }
            }
            developers {
              developer {
                id = 'chanseokoh'
                name = 'Chanseok Oh'
                email = 'chanseok@google.com'
              }
              developer {
                id = 'loosebazooka'
                name = 'Appu Goundan'
                email = 'appu@google.com'
              }
              developer {
                id = 'TadCordle'
                name = 'Tad Cordle'
                email = 'tcordle@google.com'
              }
              developer {
                id = 'briandealwis'
                name = 'Brian de Alwis'
                email = 'bdealwis@google.com'
              }
              developer {
                id = 'coollog'
                name = 'Qingyang Chen'
              }
            }
            scm {
              url = 'https://github.com/GoogleContainerTools/jib'
              connection = 'scm:https://github.com/GoogleContainerTools/jib.git'
              developerConnection = 'scm:git://github.com/GoogleContainerTools/jib.git'
            }
          }
        }
      }
    }
    generatePomFileForMavenJavaPublication {
      destination = file("${project.buildDir}/pom/${project.name}-${project.version}.pom")
    }
    // define a special install task that handles installing locally for manual testing
    task install {
      dependsOn publishToMavenLocal
    }

    // For kokoro sign and release to maven central
    task prepareRelease(type: Copy) {
      from jar
      from sourceJar
      from javadocJar
      from generatePomFileForMavenJavaPublication
      into "${project.buildDir}/release-artifacts"
      dependsOn build
      dependsOn cleanPrepareRelease
    }
  }
  /* MAVEN CENTRAL RELEASE */

  /* INCLUDED PROJECT DEPENDENCY HELPER */
  // to keep track of all source projects
  project.ext.sourceProjects = []
  // sourceProject(Project) accepts a project and adds it as a dependency in a special manner:
  // 1. force evaluation of the project first
  // 2. add the project classes as "compileOnly" and make it available to tests in "testImplementation"
  // 3. add the project's depedencies as "implementation"
  // 4. remove any transitive reference of any sourceProject depenency that may have appeared
  // 5. add the project's classes to the final jar
  // Other nice effects (vs shadowJar)
  // 1. Generated poms will be correct
  // 2. Configuration is isolated to this single "sourceProject" call
  // 3. These configurations are compliant with IDEs
  project.ext.sourceProject = { Project dependencyProject ->
    // make sure those projects are evaluated first so we know their dependencies
    project.evaluationDependsOn dependencyProject.path
    // add the sourceProjecect dependency
    def dependencyProjectClasses = dependencyProject.sourceSets.main.output
    dependencies {
      // add the dependencyProject classes as compileOnly, make it available to tests
      compileOnly(dependencyProject) { transitive = false }
      testImplementation dependencyProjectClasses
      // add dependencyProject's dependencies as implementation dependencies
      implementation dependencyProject.configurations.implementation.dependencies
      if (dependencyProject.configurations.hasProperty('api')) {
        implementation dependencyProject.configurations.api.dependencies
      }
    }
    // keep track of all dependencyProjects for removal
    sourceProjects += dependencyProject
    // if we find any project dependencies that were brought in transitively, go remove them
    project.configurations.implementation.dependencies.removeAll { d ->
      return d instanceof ProjectDependency && sourceProjects.contains(d.dependencyProject)
    }
    // adds dependencyProject's classes to jar (fat jar-esque)
    jar {
      from dependencyProjectClasses
    }
    // also configure the java-gradle-plugin if necessary
    if (project.hasProperty('gradlePlugin')) {
      project.tasks.pluginUnderTestMetadata.pluginClasspath.from dependencyProjectClasses
    }
  }

  // ensure no dependencies in the implementation group are project dependencies
  project.ext.ensureNoProjectDependencies = {
    project.afterEvaluate {
      project.configurations.implementation.dependencies.each { dependency ->
        if (dependency instanceof ProjectDependency) {
          throw new GradleException("disallowed project dependency:" + dependency + ", in project:" + project);
        }
      }
    }
  }
  /* INCLUDED PROJECT DEPENDENCY HELPER */
}


/* LOCAL DEVELOPMENT HELPER TASKS */
tasks.register('dev') {
  subprojects.each { subproject ->
    subproject.tasks.classes.dependsOn subproject.tasks.googleJavaFormat
    dependsOn subproject.tasks.check
    dependsOn subproject.tasks.javadoc
  }
}

tasks.register('devFull') {
  dependsOn tasks.dev
  subprojects.each { subproject ->
    dependsOn subproject.tasks.integrationTest
  }
}
/* LOCAL DEVELOPMENT HELPER TASKS */
